

## 莫慌 - 澄清一些常见的误解

从3.1版本开始，Lucene以及Solr使用在64位的Windows以及Solaris系统上默认使用`MMapDirectory`。从3.3版本开始，对Linux系统也进行了支持。这种更改给Lucene以及Solr用户造成了一定的困惑，因为他们的系统与之前的版本比较起来，突然变得有点奇怪。在Lucene与Solr邮件列表中，有大量的用户来询问为什么他们的Java安装突然消耗掉了三倍的物理内存，或者系统管理员抱怨太耗资源了。然后，顾问们会告诉他们不要去使用`MMapDirectory`，在`solrconfig.xml`中用`SimpleFSDirectory`（较慢）以及`NIOFSDirectory`（由于JVM的bug[#6265734](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734)导致在Windows平台上更慢）去替代。从Lucene提交者的视角来看，他们认为使用`MMapDirectory`对这些平台来说是最好的。这就有点烦人了，因为他们知道，Lucene/Solr可以比之前有更好的性能。对于这次更改的背景的常见误解，导致这个伟大的搜索引擎在任何地方都没有得到最优的安装。

在这篇博客中，我将尝试去解释操作系统的基本事实，关于虚拟内存在内核中的处理。以及为什么这个可以显著的提升Lucene的性能（“虚拟的虚拟内存”）。我也会澄清为什么许多人发的博客以及邮件列表中的帖子都是错误的，并且是与`MMapDirectory`的目的相违背的。在第二部分，我将会展示一些配置的细节与设置，以及你应该小心避免造成类似“mmap failed”这种错误，还有由于愚蠢的Java堆内存分配导致性能问题。

### 虚拟内存

让我们从操作系统的内核开始：在软件中通过本地方法去处理I/O这种方法是从20世纪70年代开始的 — 这种模式很简单：不管什么时候你想要从磁盘中获取数据，你需要在操作系统的内核中执行*syscall*，通过指针指向buffer（例如：Java中的`byte[]`），并从磁盘获取/写入数据。然后解析buffer中的内容并做你自己的程序逻辑处理。如果你不想执行太多的*syscall*（因为会消耗太多的处理能力），通常可以在你的软件中使用一个大的buffer，因此可以减少buffer中的数据与磁盘同步的次数。这也是为什么有些人建议将整个Lucene索引加载到Java堆内存中的原因（例如：通过使用`RAMDirectory`）。

但是所有的现代操作系统，例如Linux，Windows (NT+)，MacOS X，以及Solaris提供了一种更好的方式去处理20世纪70年代的这种代码风格，通过使用它们复杂的文件系统缓存以及内存管理特性。一种被称为“虚拟内存”的特性是非常好的选择去处理非常大并且空间密集型的数据结构，例如Lucene的索引。虚拟内存是计算机体系的一部分，实现需要硬件的支持。特别是以`内存管理单元（MMU)`的形式在CPU中进行构建。它的工作原理很简单：每个进程获取它自己的虚拟地址空间，所有的类库，堆以及栈空间都会映射到这个地址空间中。这个地址空间在大部分的情况下，偏移量都是从0开始，简化了加载程序中的代码，因为不需要重新定位地址指针。每个进程都可以看到并使用一个巨大的整块的线性地址空间。它就是“虚拟内存”，因为与物理内存无关，对进程来说就是这样的。软件可以访问这个巨大的地址空间就好像它是真正的内存一样，而不需要知道其他进程也在消耗内存并且有它们自己的虚拟地址空间。底层的操作系统通过CPU中MMU一起工作，一旦它们第一时间想要获取的时候，会映射它们的虚拟地址到真实的内存中。这是使用页表来完成，它是受位于MMU硬件中`TLBs`（*translation lookaside buffers*，它们缓存频繁访问的页面）支持的。这样，操作系统能够给所有运行中的进程的内存需求分配真实有效的内存，对运行中的程序来说完全透明。

<div align="center">
  <image src="https://lh4.googleusercontent.com/NltTm3thAeSa7BCj26dHUUL5or63nCqowKUGXd8QecT0NEOymEnL5ypQyFQwM-juSgwlHg3f75Im0ncbwS74NWJl8qL5DRoGENy-aZH-KnSf3WFCFZs" />
</div>

