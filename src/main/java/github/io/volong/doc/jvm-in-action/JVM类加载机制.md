#### 015 对象被回收的时机

JVM通过**可达性分析算法**来判断对象是否可以被回收。

判断每个对象是否还有一个`GC Roots`，如果有则不会被回收。

在JVM规范中，局部变量、静态变量可以看做是一种`GC Roots`。

Java中不同的引用类型：

- **强引用**：普通的变量引用一个对象
- **软引用**：`SoftReference`修饰的对象
- **弱引用**：`WeakReference`修饰的对象
- **虚引用**：

> 强引用表示绝对不能回收的对象
>
> 软引用表示可有可无的对象，在内存不够的情况下，可以回收
>
> 弱引用就跟没引用一样，发生垃圾回收时可以回收掉

如果某个对象重写了`Object`类中的`finalize()`方法，则会调用该方法去判断实例对象是否被某个`GC Roots`变量重新引用了，如果是则不会被回收。



---



#### 016 垃圾回收算法

新生代的回收算法 — **复制算法**

**假的复制算法**：把新生代划分为两块内存区域，只使用其中一块，等这块内存快满时，把里面存活的对象一次性转移到另一块内存区域，这样可以保证没有内存碎片。接着一次性回收原来那块内存中的垃圾对象，再次空出来一块内存区域。两块内存交替使用。

缺点：新生代内存只有一半可以使用，内存使用率低。

优化：一次垃圾回收后，大部分的对象都被垃圾回收，只有小部分对象存活。这部分对象可能是一些长期存活的对象或者还没被使用完的对象。

**真正的复制算法**：把新生代划分为三块：1个`Eden`区，2个`Survivor`区。`Eden`区占80%的空间，每一块`Survivor`区占10%的空间。

对象分配都是在`Eden`区，如果`Eden`区快满了，触发垃圾回收会把`Eden`区中存活的对象转移到一块空着的`Survivor`区。然后清空`Eden`区，接着对象继续分配在`Eden`区，再次垃圾回收会把`Eden`区与使用中的`Survivor`区中存活的对象转移到另一块空的`Survivor`区中，然后清空垃圾对象。如此重复使用三块内存区域。

优点：只有10%的空间被浪费，大部分内存都在使用。

