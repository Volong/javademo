#### 003 JVM类加载机制

一个类从加载到使用，一般会经历如下过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

加载：在代码中用到这个类时，“.class”字节码文件会加载这个类到JVM内存里面来。

验证：校验加载进来的“.class”文件是否符合JVM规范。

准备：给类分配内存空间，并对类变量分配内存空间，并赋默认值。

解析：把符号引用替换为直接引用。

初始化：执行类的初始化代码。这个时候才会真正的给变量赋我们编码的值。

初始化类的时机：

1. 通过关键词`new`实例化类时
2. 包含`main()`方法的主类

初始化一个类时，如果它的父类还没初始化，则必须先初始化他的父类。

类加载器：

1. **启动类加载器（Bootstrap ClassLoader）**

   加载Java安装目录下`lib`目录中的核心类库

2. **扩展类加载器（Extension ClassLoader）**

   加载Java安装目录下`lib/ext`目录中的类

3. **应用程序类加载器（Application ClassLoader）**

   加载`classpath`路径中的类。可以理解为加载我们写好的那些类

4. **自定义类加载器**

   自己定义，按照我们的需求去加载类

双亲委派模型：以上类加载器按照加载类的优先级从上到下一次降低。

类加载器在加载一个类时，会先委托给自己的父类加载器，最终会委托到顶层的类加载器，如果类加载器在自己负责加载的范围内没有找到这个类，才会让自己的子类加载器去加载。

如何对`.class`文件进行处理而不会被反编译？

在编译时，对字节码进行加密，在加载时使用自定义的类加载器来解密文件。



---



#### 004 JVM内存区域

**方法区：**存放从`.class`文件中加载进来的类，还有常量池。

> JDK 1.8之后叫做`Metaspace`，元数据空间

**程序计数器：**记录当前执行的字节码指令的位置。

每一个线程都会有一个自己的程序计数器，专门用于记录当前线程目前执行到哪条字节码指令。

**Java虚拟机栈：**保存每个方法内局部变量等数据。

每个线程都有自己的虚拟机栈，每执行一个方法，就会创建一个对应的**栈帧**。栈帧里面有方法的局部变量表、操作数栈、动态链接、方法出口等。

**Java堆内存：**存放创建的各种对象。

**本地方法栈：**存放各种`native`方法中的局部变量等数据。

每个线程都有对应的本地方法栈，与Java虚拟机栈类似。

**堆外内存：**这块内存区域不属于JVM，通过`NIO`的`API`可以在Java堆外分配内存空间，然后通过Java虚拟机中的`DirectByteBuffer`来引用和操作堆外内存空间。

一个对象占用的内存空间大致分为两块：

- 对象自己本身的信息
- 对象的实例作为数据占用的空间

> 对象头在64位的Linux上，占用16个字节。`int`类型的实例变量占`4`个字节，`long`类型的占`8`个字节



---



#### 008 JVM分代模型

根据对象的生存周期不同，JVM将Java堆内存分为两个区域：年轻代、老年代。

年轻代：创建和使用完之后需要进行回收的对象在里面

老年代：创建之后会长期存在的对象在里面

永久代：其实就是方法区，用来存放类信息



---



#### 009 对象在JVM内存中的分配

大部分对象都是优先在新生代分配内存。

新生代内存的垃圾回收被称为`Minor GC`或者`Young GC`。

如果一个实例对象在新生代中，在一定次数的垃圾回收之后，还没有被回收掉，会被转移到老年代中。



---



#### 010 设置JVM内存大小

核心参数：

- `-Xms`：堆内存大小

- `-Xmx`：堆内存的最大大小

- `-Xmn`：堆内存中新生代大小。减去这个值就是老年代大小

- `-XX:PermSize`：永久代大小

- `-XX:MaxPermSize`：永久代最大大小

  > JDK 1.8之后，这个两个参数改为：`-XX:MetaspaceSize`与`-XX:MaxMetaspaceSize`

- `-Xss`：每个线程的栈内存大小



---



#### 015 对象被回收的时机

JVM通过**可达性分析算法**来判断对象是否可以被回收。

判断每个对象是否还有一个`GC Roots`，如果有则不会被回收。

在JVM规范中，局部变量、静态变量可以看做是一种`GC Roots`。

Java中不同的引用类型：

- **强引用**：普通的变量引用一个对象
- **软引用**：`SoftReference`修饰的对象
- **弱引用**：`WeakReference`修饰的对象
- **虚引用**：

> 强引用表示绝对不能回收的对象
>
> 软引用表示可有可无的对象，在内存不够的情况下，可以回收
>
> 弱引用就跟没引用一样，发生垃圾回收时可以回收掉

如果某个对象重写了`Object`类中的`finalize()`方法，则会调用该方法去判断实例对象是否被某个`GC Roots`变量重新引用了，如果是则不会被回收。



------



#### 016 垃圾回收算法

新生代的回收算法 — **复制算法**

**假的复制算法**：把新生代划分为两块内存区域，只使用其中一块，等这块内存快满时，把里面存活的对象一次性转移到另一块内存区域，这样可以保证没有内存碎片。接着一次性回收原来那块内存中的垃圾对象，再次空出来一块内存区域。两块内存交替使用。

缺点：新生代内存只有一半可以使用，内存使用率低。

优化：一次垃圾回收后，大部分的对象都被垃圾回收，只有小部分对象存活。这部分对象可能是一些长期存活的对象或者还没被使用完的对象。

**真正的复制算法**：把新生代划分为三块：1个`Eden`区，2个`Survivor`区。`Eden`区占80%的空间，每一块`Survivor`区占10%的空间。

对象分配都是在`Eden`区，如果`Eden`区快满了，触发垃圾回收会把`Eden`区中存活的对象转移到一块空着的`Survivor`区。然后清空`Eden`区，接着对象继续分配在`Eden`区，再次垃圾回收会把`Eden`区与使用中的`Survivor`区中存活的对象转移到另一块空的`Survivor`区中，然后清空垃圾对象。如此重复使用三块内存区域。

优点：只有10%的空间被浪费，大部分内存都在使用。



---



#### 017 老年代垃圾回收算法

- 默认情况下，当对象躲过了`15`次GC后，会被转移到老年代中

  可以通过参数`-XX:MaxTenuringThreshold`来设置。

- 动态年龄判断：年龄1 + 年龄2 + … + 年龄n的对象总和超过了`Survivior`区域50%，则会把年龄**大于等于n**的对象都放入老年代

- 大对象直接进入老年代

  可以通过参数`-XX:PretenureSizeThreshold`设置，默认为`0`，单位为字节。

- `Minor GC`后的对象太多无法放入`Survivor`区，则直接转移到老年代中

老年代空间**分配担保规则：**

- 在执行任何一次`Minor GC`之前，JVM会先检查老年代可用的内存空间是否大于新生代所有对象的总大小。

  - 如果大于则执行`Minor GC`

  - 如果小于则会检查`-XX:-HandlePromotionFailure`参数是否设置。
    
    - 如果设置了，则会看老年代内存大小是否大于之前每次`Minor GC`后进入老年代的对象的平均大小。
      - 如果大于，则执行`Minor GC`
        - 执行之后发现存活对象大于`Survivor`，也大于老年代可用内存，会产生`Handle Promotion Failure`异常，触发`Full GC`
      - 如果小于，则执行`Full GC`
    - 如果没设置，则执行`Full GC`
    
    如果执行完`Full GC`后，老年代还是没有足够的空间存放`Minor GC`后的存活对象，则会导致`OOM`异常。

老年代垃圾回收算法 — **标记整理算法**

- 标记老年代当前存活的对象，让这些存活对象在内存里进行移动，把存活对象移动到一边，让这些对象紧凑的靠在一起，避免垃圾回收后产生过多的内存碎片。



---



#### 018 常见垃圾回收器







