#### 003 JVM类加载机制

一个类从加载到使用，一般会经历如下过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

加载：在代码中用到这个类时，“.class”字节码文件会加载这个类到JVM内存里面来。

验证：校验加载进来的“.class”文件是否符合JVM规范。

准备：给类分配内存空间，并对类变量分配内存空间，并赋默认值。

解析：把符号引用替换为直接引用。

初始化：执行类的初始化代码。这个时候才会真正的给变量赋我们编码的值。

初始化类的时机：

1. 通过关键词`new`实例化类时
2. 包含`main()`方法的主类

初始化一个类时，如果它的父类还没初始化，则必须先初始化他的父类。

类加载器：

1. **启动类加载器（Bootstrap ClassLoader）**

   加载Java安装目录下`lib`目录中的核心类库

2. **扩展类加载器（Extension ClassLoader）**

   加载Java安装目录下`lib/ext`目录中的类

3. **应用程序类加载器（Application ClassLoader）**

   加载`classpath`路径中的类。可以理解为加载我们写好的那些类

4. **自定义类加载器**

   自己定义，按照我们的需求去加载类

双亲委派模型：以上类加载器按照加载类的优先级从上到下一次降低。

类加载器在加载一个类时，会先委托给自己的父类加载器，最终会委托到顶层的类加载器，如果类加载器在自己负责加载的范围内没有找到这个类，才会让自己的子类加载器去加载。

如何对`.class`文件进行处理而不会被反编译？

在编译时，对字节码进行加密，在加载时使用自定义的类加载器来解密文件。



---



#### 004 JVM内存区域

**方法区：**存放从`.class`文件中加载进来的类，还有常量池。

> JDK 1.8之后叫做`Metaspace`，元数据空间

**程序计数器：**记录当前执行的字节码指令的位置。

每一个线程都会有一个自己的程序计数器，专门用于记录当前线程目前执行到哪条字节码指令。

**Java虚拟机栈：**保存每个方法内局部变量等数据。

每个线程都有自己的虚拟机栈，每执行一个方法，就会创建一个对应的**栈帧**。栈帧里面有方法的局部变量表、操作数栈、动态链接、方法出口等。

**Java堆内存：**存放创建的各种对象。

**本地方法栈：**存放各种`native`方法中的局部变量等数据。

每个线程都有对应的本地方法栈，与Java虚拟机栈类似。

**堆外内存：**这块内存区域不属于JVM，通过`NIO`的`API`可以在Java堆外分配内存空间，然后通过Java虚拟机中的`DirectByteBuffer`来引用和操作堆外内存空间。

一个对象占用的内存空间大致分为两块：

- 对象自己本身的信息
- 对象的实例作为数据占用的空间

> 对象头在64位的Linux上，占用16个字节。`int`类型的实例变量占`4`个字节，`long`类型的占`8`个字节



---



#### 008 JVM分代模型

根据对象的生存周期不同，JVM将Java堆内存分为两个区域：年轻代、老年代。

年轻代：创建和使用完之后需要进行回收的对象在里面

老年代：创建之后会长期存在的对象在里面

永久代：其实就是方法区，用来存放类信息



---



#### 009 对象在JVM内存中的分配

大部分对象都是优先在新生代分配内存。

新生代内存的垃圾回收被称为`Minor GC`或者`Young GC`。

如果一个实例对象在新生代中，在一定次数的垃圾回收之后，还没有被回收掉，会被转移到老年代中。



---



#### 010 设置JVM内存大小

核心参数：

- `-Xms`：堆内存大小

- `-Xmx`：堆内存的最大大小

- `-Xmn`：堆内存中新生代大小。减去这个值就是老年代大小

- `-XX:PermSize`：永久代大小

- `-XX:MaxPermSize`：永久代最大大小

  > JDK 1.8之后，这个两个参数改为：`-XX:MetaspaceSize`与`-XX:MaxMetaspaceSize`

- `-Xss`：每个线程的栈内存大小



---



#### 015 对象被回收的时机

JVM通过**可达性分析算法**来判断对象是否可以被回收。

判断每个对象是否还有一个`GC Roots`，如果有则不会被回收。

在JVM规范中，局部变量、静态变量可以看做是一种`GC Roots`。

Java中不同的引用类型：

- **强引用**：普通的变量引用一个对象
- **软引用**：`SoftReference`修饰的对象
- **弱引用**：`WeakReference`修饰的对象
- **虚引用**：

> 强引用表示绝对不能回收的对象
>
> 软引用表示可有可无的对象，在内存不够的情况下，可以回收
>
> 弱引用就跟没引用一样，发生垃圾回收时可以回收掉

如果某个对象重写了`Object`类中的`finalize()`方法，则会调用该方法去判断实例对象是否被某个`GC Roots`变量重新引用了，如果是则不会被回收。



------



#### 016 垃圾回收算法

新生代的回收算法 — **复制算法**

**假的复制算法**：把新生代划分为两块内存区域，只使用其中一块，等这块内存快满时，把里面存活的对象一次性转移到另一块内存区域，这样可以保证没有内存碎片。接着一次性回收原来那块内存中的垃圾对象，再次空出来一块内存区域。两块内存交替使用。

缺点：新生代内存只有一半可以使用，内存使用率低。

优化：一次垃圾回收后，大部分的对象都被垃圾回收，只有小部分对象存活。这部分对象可能是一些长期存活的对象或者还没被使用完的对象。

**真正的复制算法**：把新生代划分为三块：1个`Eden`区，2个`Survivor`区。`Eden`区占80%的空间，每一块`Survivor`区占10%的空间。

对象分配都是在`Eden`区，如果`Eden`区快满了，触发垃圾回收会把`Eden`区中存活的对象转移到一块空着的`Survivor`区。然后清空`Eden`区，接着对象继续分配在`Eden`区，再次垃圾回收会把`Eden`区与使用中的`Survivor`区中存活的对象转移到另一块空的`Survivor`区中，然后清空垃圾对象。如此重复使用三块内存区域。

优点：只有10%的空间被浪费，大部分内存都在使用。



---



#### 017 老年代垃圾回收算法

- 默认情况下，当对象躲过了`15`次GC后，会被转移到老年代中

  可以通过参数`-XX:MaxTenuringThreshold`来设置。

- 动态年龄判断：年龄1 + 年龄2 + … + 年龄n的对象总和超过了`Survivior`区域50%，则会把年龄**大于等于n**的对象都放入老年代

- 大对象直接进入老年代

  可以通过参数`-XX:PretenureSizeThreshold`设置，默认为`0`，单位为字节。

- `Minor GC`后的对象太多无法放入`Survivor`区，则直接转移到老年代中

老年代空间**分配担保规则：**

- 在执行任何一次`Minor GC`之前，JVM会先检查老年代可用的内存空间是否大于新生代所有对象的总大小。

  - 如果大于则执行`Minor GC`

  - 如果小于则会检查`-XX:-HandlePromotionFailure`参数是否设置。
    
    - 如果设置了，则会看老年代内存大小是否大于之前每次`Minor GC`后进入老年代的对象的平均大小。
      - 如果大于，则执行`Minor GC`
        - 执行之后发现存活对象大于`Survivor`，也大于老年代可用内存，会产生`Handle Promotion Failure`异常，触发`Full GC`
      - 如果小于，则执行`Full GC`
    - 如果没设置，则执行`Full GC`
    
    如果执行完`Full GC`后，老年代还是没有足够的空间存放`Minor GC`后的存活对象，则会导致`OOM`异常。

老年代垃圾回收算法 — **标记整理算法**

- 标记老年代当前存活的对象，让这些存活对象在内存里进行移动，把存活对象移动到一边，让这些对象紧凑的靠在一起，避免垃圾回收后产生过多的内存碎片。

> `-XX:HandlePromotionFailure`在JDK 1.6之后被废弃了。JDK 1.6之后，只要判断“老年代可用空间” > “新生代对象总和”或者“老年代可用空间” > "`Minor GC`后进入老年代对象的平均大小"，两个条件满足一个，就会进行`Minor GC`，不会触发`Full GC` — （025）

---



#### 018 常见垃圾回收器

`Serial`、`Serial Old`垃圾回收器：分别用来回收新生代、老年代的垃圾对象

> 单线程运行，垃圾回收时会停止应用的线程，再进行垃圾回收。（现在一般不用）

`ParNew`垃圾回收器一般用于新生代。`CMS`垃圾回收器用于老年代。

> 它们都是多线程并发回收，大大缩短回收的时间

`G1`垃圾回收器统一收集新生代和老年代。



---



#### 022 年轻代垃圾回收器ParNew

使用`-XX:+UseParNewGC`指定使用`ParNew`垃圾回收器对新生代进行垃圾回收。

`ParNew`垃圾回收器默认的线程数量为CPU的**核数**。

> 可通过`-XX:ParallelGCThreads`参数来指定



---



#### 023 老年代垃圾回收器CMS

`CMS`使用的是标记整理算法。

在`Stop the World`的时候，如果采用标记整理算法去回收垃圾，会导致系统长时间卡顿。所以`CMS`采取的是**垃圾回收线程与应用工作线程尽量同时执行的模式来处理。**

因此`CMS`执行垃圾回收时会分为4个阶段：

- 初始标记

  会让应用的线程全部停止，进入`Stop the Wolrd`状态。标记所有`GC Roots`**直接**引用的对象

  > 方法的局部变量和类的静态变量是`GC Roots`，类的实例变量不是`GC Roots`
  >
  > 虽然会进入`Stop the World`状态，但是速度非常快，因为仅仅标记`GC Roots`直接引用的对象

- 并发标记

  让应用继续运行，对老年代里所有间接引用的对象进行`GC Roots`追踪。最耗时

- 重新标记

  进入`Stop the World`状态，对第二阶段产生的对象重新标记

  > 速度较快，因为只是对变动过的对象进行标记

- 并发清理

  让应用继续运行，清理掉标记为垃圾的对象



---



#### 024 设置垃圾回收参数

垃圾回收器在并发标记与并发清理阶段，会占用CPU资源。`CMS`默认启动的垃圾回收线程数量为：`(CPU核数 + 3) / 4`

> 所以`CMS`的第一个问题是会消耗CPU资源

**浮动垃圾** — 在并发清理阶段，可能会有对象进入老年代并变成垃圾对象。

所以为了给老年代预留一点空间，当老年代占用一定比例时会触发`CMS`的垃圾回收。

> 通过`-XX:CMSInitiatingOccupancyFaction`进行设置
>
> JDK 1.6的默人值为`92%`

如果在`CMS`垃圾回收期间，要进入老年代的对象大于可用内存，会发生`Concurrent Mode Faulure`异常。这时会用`Serial Old`垃圾回收器代替`CMS`，直接强制系统进入`Stop the World`状态，重新进行`GC Roots`追踪，标记全部垃圾对象，然后再回收，再恢复应用运行。

`CMS`通过如下两个参数来控制内存的整理：

- `-XX:+Us CMSCompactAtFullCollection`：表示`Full GC`之后进入`Stop the World`，停止工作线程，进行碎片整理，把存活对象移到一起。

  默认打开。

- `-XX:+CMSFullGCsBeforeCompaction`：表示执行多少次`Full GC`后再执行一次内存碎片整理。

  默认为`0`，即每次都进行一次内存整理



---



#### 029 G1垃圾回收器的工作原理

`G1`垃圾回收器可以同时回收新生代和老年代的对象。它把Java堆内存分为多个大小相等的`Region`，每个`Region`可能属于新生代，也可能属于老年代，由`G1`自动控制。

我们可以设置垃圾回收的预期停顿时间。`G1`会追踪每个`Region`中可回收对象的大小和预估时间，在垃圾回收时，尽量把垃圾回收对应用造成的影响控制在指定的时间范围内，在有限的时间内尽可能多的回收垃圾对象。



---



#### 030 G1的内存模型和分配规则

可以通过`-XX:+UseG1GC`来指定使用`G1`垃圾回收器。

JVM最多有`2048`个`Region`，每个`Region`的大小必须是`2`的倍数。默认情况下，每个`Region`的大小就是堆内存除以`2048`。

可以通过`-XX:G1HeapRegionSize`来指定每个`Region`的大小，取值范围从`1M`到`32M`，且是`2`的倍数。

默认情况下，新生代占堆内存的`5%`，可以通过`-XX:G1NewSizePercent`来指定新生代初始占比，通过`-XX:G1MaxNewSizePercent`来指定新生代的最大占比，默认为`60%`。

还是通过`-XX:SurvivorRatio`来区分`Eden`和`Survivor`的比例。

一旦新生代在堆内存中的占比达到最大大小，会触发垃圾回收，回收算法为复制算法。通过`-XX:MaxGCPauseMillis`来设置GC的停顿时间，默认为`200ms`。

对象从新生代进入老年代的条件：

- 对象的年龄达到了指定的值
- 动态年龄判断

`G1`提供了专门的`Region`来存放大对象，而不是让大对象直接进入老年代的`Region`中。如果一个对象的大小超过了`Region`大小的`50%`，就会被当作大对象。

如果一个大对象超过了一个`Region`的大小，则会被放入多个`Region`中。在新生代、老年代进行回收时，会对大对象`Region`一起回收。



---



#### 031 G1垃圾回收机制

当老年代占了堆内存`45%`的`Region`时，会触发新生代与老年代的混合回收（`Mixed GC`）。会对新生代、老年代、大对象进行回收。

这个占比可以通过`-XX:InitiatingHeapOccupancyPercent`进行设置，默认值为`45%`。

`G1`混合回收过程：

- 初始标记

  进入`Stop the World`状态，仅仅标记一下`GC Roots`直接引用的对象

- 并发标记

  允许应用继续运行，同时进行`GC Roots`追踪所有存活的对象

- 最终标记

  进入`Stop the World`状态，根据并发标记阶段记录的对象，标记对象是否存活

- 混合回收

  计算老年代中每个`Region`中存活对象的数量、占比，垃圾回收的预期性能和效率。停止应用，进行垃圾回收，为了让垃圾回收的停顿时间控制在我们指定的范围内，并尽可能的回收多的垃圾，可能只会选择部分`Region`进行回收。











