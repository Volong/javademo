#### 003 JVM类加载机制

一个类从加载到使用，一般会经历如下过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

加载：在代码中用到这个类时，“.class”字节码文件会加载这个类到JVM内存里面来。

验证：校验加载进来的“.class”文件是否符合JVM规范。

准备：给类分配内存空间，并对类变量分配内存空间，并赋默认值。

解析：把符号引用替换为直接引用。

初始化：执行类的初始化代码。这个时候才会真正的给变量赋我们编码的值。

初始化类的时机：

1. 通过关键词`new`实例化类时
2. 包含`main()`方法的主类

初始化一个类时，如果它的父类还没初始化，则必须先初始化他的父类。

类加载器：

1. **启动类加载器（Bootstrap ClassLoader）**

   加载Java安装目录下`lib`目录中的核心类库

2. **扩展类加载器（Extension ClassLoader）**

   加载Java安装目录下`lib/ext`目录中的类

3. **应用程序类加载器（Application ClassLoader）**

   加载`classpath`路径中的类。可以理解为加载我们写好的那些类

4. **自定义类加载器**

   自己定义，按照我们的需求去加载类

双亲委派模型：以上类加载器按照加载类的优先级从上到下一次降低。

类加载器在加载一个类时，会先委托给自己的父类加载器，最终会委托到顶层的类加载器，如果类加载器在自己负责加载的范围内没有找到这个类，才会让自己的子类加载器去加载。

如何对`.class`文件进行处理而不会被反编译？

在编译时，对字节码进行加密，在加载时使用自定义的类加载器来解密文件。



---



#### 004 JVM内存区域

**方法区：**存放从`.class`文件中加载进来的类，还有常量池。

> JDK 1.8之后叫做`Metaspace`，元数据空间

**程序计数器：**记录当前执行的字节码指令的位置。

每一个线程都会有一个自己的程序计数器，专门用于记录当前线程目前执行到哪条字节码指令。

**Java虚拟机栈：**保存每个方法内局部变量等数据。

每个线程都有自己的虚拟机栈，每执行一个方法，就会创建一个对应的**栈帧**。栈帧里面有方法的局部变量表、操作数栈、动态链接、方法出口等。

**Java堆内存：**存放创建的各种对象。

**本地方法栈：**存放各种`native`方法中的局部变量等数据。

每个线程都有对应的本地方法栈，与Java虚拟机栈类似。

**堆外内存：**这块内存区域不属于JVM，通过`NIO`的`API`可以在Java堆外分配内存空间，然后通过Java虚拟机中的`DirectByteBuffer`来引用和操作堆外内存空间。

一个对象占用的内存空间大致分为两块：

- 对象自己本身的信息
- 对象的实例作为数据占用的空间

> 对象头在64位的Linux上，占用16个字节。`int`类型的实例变量占`4`个字节，`long`类型的占`8`个字节



---



#### 008 JVM分代模型

根据对象的生存周期不同，JVM将Java堆内存分为两个区域：年轻代、老年代。

年轻代：创建和使用完之后需要进行回收的对象在里面

老年代：创建之后会长期存在的对象在里面

永久代：其实就是方法区，用来存放类信息



---



#### 009 对象在JVM内存中的分配

大部分对象都是优先在新生代分配内存。

新生代内存的垃圾回收被称为`Minor GC`或者`Young GC`。

如果一个实例对象在新生代中，在一定次数的垃圾回收之后，还没有被回收掉，会被转移到老年代中。



---



#### 010 设置JVM内存大小

核心参数：

- `-Xms`：堆内存大小

- `-Xmx`：堆内存的最大大小

- `-Xmn`：堆内存中新生代大小。减去这个值就是老年代大小

- `-XX:PermSize`：永久代大小

- `-XX:MaxPermSize`：永久代最大大小

  > JDK 1.8之后，这个两个参数改为：`-XX:MetaspaceSize`与`-XX:MaxMetaspaceSize`

- `-Xss`：每个线程的栈内存大小

