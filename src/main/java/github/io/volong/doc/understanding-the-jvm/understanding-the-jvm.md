>   《深入理解 Java 虚拟机》 笔记

### 2.2 运行时数据区域

Java 虚拟机所管理的内存包括以下几个运行时数据区域：

![](images/2-1.png)



#### 2.2.2.1 程序计数器

`程序计数器 (Program Counter Register)` 是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

字节码解析器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。

由于 Java 虚拟机的多线程是通过线程轮询并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为 "线程私有" 的内存。

如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。
如果正在执行的是 `Native` 方法，这个计数器值则为空 (`Undefined`)。

此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域。

#### 2.2.2 Java 虚拟机栈

`Java 虚拟机栈 (Java Virtual Machine Stacks)` 也是线程私有的，它的生命周期与线程相同。

虚拟机栈描述的就是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧** (`Stack Frame`) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈。

**局部变量表**存放了编译期可知的各种基本数据类型、对象引用和 `returnAddress` 类型。

>   **基本数据类型 :** boolean、byte、char、short、int、float、long、double  
>   **对象引用 :** reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置。  
>   **`returnAddress` 类型 :** 指向一条字节码指令的地址。

64 位长度的 `long` 和 `double` 类型的数据会占用 2 个局部变量空间 (slot)，其余的数据类型只占用 1 个。
局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

Java 虚拟机规范对这个区域规定了两种异常情况：

-   如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError` 异常

-   如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，将会抛出 `OutOfMemoryError` 异常。

    >   大部分的 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈。

#### 2.2.3 本地方法栈

`本地方法栈 (Native Method Stack)` 与虚拟机栈的作用相似，不同点在于虚拟机栈为虚拟机执行 Java 方法 ( 字节码 ) 服务，而本地方法栈则为虚拟机使用到的 `Native` 方法服务。

在虚拟机规范中，对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，所以虚拟机可以自由实现它。

>   有的虚拟机 (例 : Sun HotSpot 虚拟机) 直接将本地方法栈与虚拟机栈合二为一。

与虚拟机栈一样，本地方法栈区域也会抛出 `StackOverflowError` 和 `OutOfMemoryError` 异常。

#### 2.2.4 Java 堆

`堆 (Heap)` 是被所有线程共享的一块内存区域，在虚拟机启动时创建。

此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

>   栈上分配、标量替换优化技术会有一点不同

堆是垃圾收集器管理的主要区域，因此也被称为 "GC 堆" (`Garbage Collected Heap`)。

从内存回收的角度看，由于现在收集器基本都采用**分代收集算法**，所以堆还可以细分为 : 新生代和老年代；还可以再细分为 `Eden` 空间、`From Survivor` 空间、`To Survivor` 空间。

从内存分配的角度看，线程共享的堆中可以划分出多个线程私有的**分配缓冲区** (`Thread Local Allocation Buffer, TLAB`)。

根据 Java 虚拟机规范，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 `OutOfMemoryError` 异常。

#### 2.2.5 方法区

`方法区 (Method Area)` 与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区与永久代（Permanent Generation）本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区。

根据 Java 虚拟机规范，当方法区无法满足内存分配需求时，将抛出 `OutOfMemoryError` 异常。

#### 2.2.6 运行时常量池

`运行时常量池 (Runtime Constant Pool)` 是方法区的一部分。

`Class` 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池 (`Constant Pool Table`)，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放。

Java 虚拟机规范对运行时常量池没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。
一般来说，除了保存 `Class` 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

并不一定只有编译期产生的常量才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。

>   例如：String.intern() 方法

作为方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 异常。

#### 2.2.7 直接内存

`直接内存 (Direct Memory)` 既不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。

本机直接内存的分配不会受到 Java 堆大小的限制，但是肯定会受到本机总内存大小以及处理器寻址空间的限制。如果在配置虚拟机参数时，忽略了直接内存，使得各个内存区域总和大于物理内存限制，会导致动态扩展时出现 `OutOfMemoryError` 异常。

### 2.3 HotSpot 虚拟机对象探秘

深入探讨 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

>   对象仅限于普通 Java 对象，不包括数组和 Class 对象

#### 2.3.1 对象的创建

虚拟机遇到一条 `new` 指令时，首先将会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则先执行相应的类加载过程。

在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载后可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

内存的分配方式：

-   **指针碰撞 (Bump the Pointer)** : 假设 Java 堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离。
-   **空闲列表 (Free List)** : 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

在使用 **Serial (串行)**、**ParNew (并行)** 等带有压缩整理的收集器时，系统采用的分配算法是指针碰撞，而使用基于**标记清除算法 (Mark-Sweep)** 的 **CMS (Concurrent Mark Sweep)** 收集器时，通常采用空闲列表。

由于在虚拟机中，对象创建是非常频繁的行为，所以在并发情况下需要保证线程安全。  
解决这个问题的两种方案如下：

-   对分配内存空间的动作进行同步处理，采用 *CAS* 的方式保证更新操作的原子性。

-   把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲区 (TLAB)。哪个线程需要分配内存，就在哪个线程的 `TLAB` 上分配，只有 `TLAB` 用完并分配新的 `TLAB` 时，才需要同步锁定。

    >   虚拟机是否使用 TLAB，可以通过 `-XX:+/-UseTLAB` 来设置

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值 (不包括对象头)。如果使用 TLAB，这个过程将会在 `TLAB` 分配时进行。  
这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

接下来，虚拟机对对象的一些信息进行设置，将这些信息保存在**对象头 (Object Header)** 中。

>   例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息

根据虚拟机当前的运行状态的不同，对象头会有不同的设置方式。

>   例如是否使用偏向锁等

在上面的工作都完成了之后，从虚拟机的角度来看，一个新的对象已经产生了，但是从 Java 程序的角度看，对象创建才刚刚开始，因为 `<init>` 方法还没有执行，所有的字段都还为零。所以，一般来说，执行 `new` 指令后会执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这时候一个可用的对象才算初始化完全。

#### 2.3.2 对象的内存布局

在 HotSpot 虚拟机中，对象在内存中存储的布局分为 3 块区域：对象头 (`Head`)、实例数据 (`Instance Data`)、对齐填充 (`Padding`)。

**对象头**包含两部分信息：

-   存储对象自身的运行时数据

    >   例如：哈希码 (`HashCode`)、GC 分带年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等

    这部分数据的长度在 32 位和 64 位的虚拟机 (未开启压缩指针) 中分别为 `32bit` 和 `64bit`，称为 `Mark Word`。

-   类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

    >   但是不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据信息并不一定要经过对象本身。
    >
    >   如果对象是一个 Java 数组，那么在对象头还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。

**实例数据部分**是对象真正存储的有效信息。也就是程序代码中定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数 (`FieldsAllocationStyle`) 和字段在 Java 源码中定义顺序的影响。

HotSpot 虚拟机默认的分配策略为 `longs/doubles`、`ints`、`shorts/chars`、`bytes/booleans`、`oops (Ordinary Object Pointers)`，从分配策略中可以看出来，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 `CompactFields` 参数值为 `true` (默认为 `true`)，那么子类中较窄的变量也可能会插入到父类变量的空隙之中。

**对齐填充**不是必然存在的，它仅仅起到占位符的作用。因为 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说，对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数 (1 倍或 2 倍)，所以当对象实例数据没有对齐时，就需要通过对齐填充来补全。

#### 2.3.3 对象的定位访问

Java 程序需要通过栈上的 `reference` 数据来操作堆上的具体对象。由于 `referenece` 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，所以对象的访问方式也是取决于虚拟机的实现。

主要有如下两种访问方式：

-   **句柄访问** : Java 堆中将会划分出一块内存来作为句柄池，`reference` 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

    ![](images/access-by-handle.png)

-   **直接指针访问** : Java 堆对象的布局中放置访问类型数据的相关信息，`reference` 中存储对象的地址。

    ![](images/access-by-pointer.png)

使用句柄访问的最大好处是 `reference` 中存储的是稳定的句柄地址，在对象被移动时（垃圾收集时会移动对象）只会改变句柄中的实例数据指针，而 `reference` 本身不需要修改。

使用直接指针访问的最大好处是速度更快，它节省了一次指针定位的时间开销。

>   Sun HotSpot 使用第二种方式进行对象访问

#### 2.4.1 Java 堆溢出

Java 堆用于存储对象实例，只要不断地创建对象，并且保证 `GC Roots` 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

>   将堆的最小值 `-Xms` 参数与最大值 `-Xmx` 参数设置为一样可避免堆自动扩展

#### 2.4.2 虚拟机栈和本地方栈溢出

由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，所以 `-Xoss` 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 `-Xss` 参数设定。

关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常：

-   如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 `StackOverflowError` 异常。
-   如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

>   经测试

在单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 `StackOverflowError` 异常。

在多线程下，为每个线程的栈分配的内存越大，越容易产生内存溢出异常。

在多线程情况下导致的内存溢出，在不能减少线程数或更换 64 位虚拟机的情况下，可以通过减少最大堆和减少栈容量来换取更多的线程。

#### 2.4.3 方法区和运行时常量池溢出

在 JDK1.6 中，`intern()` 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。

在 JDK1.7 中，`intern()` 方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用。

方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当前的很多主流框架，如 Spring 在对类进行增强时会使用到 `CGLib` 这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class 可以加载到内存。

#### 2.4.4 本机直接内存溢出

**直接内存**可以通过 `-XX:MaxDirectMemorySize` 指定，如果不指定，则默认与 Java 堆最大值（`-Xmx` 指定） 一样。

### 3.2 对象已死吗

垃圾收集器在对堆进行回收之前，第一件事情就是要确定哪些对象不再被使用，即判断对象是否还存活。

#### 3.2.1 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时候计数器为 0 的对象就是不会再被使用的。

但是该算法很难解决对象之间相互循环引用的问题。

#### 3.2.2 可达性分析算法

通过一系列称为”GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

![GC-Roots](images/GC-Roots.png)

在 Java 中，可作为 GC Roots 的对象为一下几种：

-   虚拟机栈（栈帧中的本地变量表）中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   本地方法中 JNI （即 `Native` 方法）引用的对象

#### 3.2.3 再谈引用

JDK 1.2 之前，Java 中对引用的定义为，如果 `referenece` 类型的数据中存储的数值代表的是另外一块内存的起始地址，就成这块内存代表着一个引用。

JDK 1.2 之后，将引用分为如下四种：

-   强引用（Strong Reference）

    强引用在程序中普遍存在，类似 `Object obj = new Object()` 这类的引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

-   软引用（Soft Reference）

    用来描述那些还有用但是并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，将会抛出内存溢出异常。使用 `SoftReference` 类实现软引用。

-   弱引用（Weak Reference）

    也是用来描述非必需对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。使用 `WeakReference` 类来实现弱引用。

-   虚引用（Phantom Reference）

    它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。使用 `PhantomReference` 类来实现虚引用。

这 4 种引用强度依次逐渐减弱。

#### 3.2.4 生存还是死亡

一个对象是否被回收要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。

当对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。

如果这个对象被判定为有必要执行 `finalize()` 方法，那么这个对象将会被放置在一个叫做 `F-Queue` 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 `Finalizer` 线程去执行它。

>   执行的意思是指：虚拟机会触发这个方法，但并不保证会等待它运行结束。因为，如果一个对象在 `finalize()` 方法中执行缓慢，或者发生了死循环，将可能会导致 `F-Queue` 队列中其他对象永久处于等待，甚至导致整个内存回收体系崩溃

稍后 GC 会对 `F-Queue` 中的对象进行第二次小规模的标记，如果对象在 `finalize()` 方法中重新与引用链上的任何一个对象建立关联（比如把自己赋值给某个类变量或者对象的成员变量），那么第二次标记时它将被移出队列。如果对象没有重新与引用链上的其它对象相关联，那么就会被回收了。

>   任何一个对象的 `finalize()` 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 `finalize()` 方法不会被再次执行。

#### 3.2.5 回收方法区

Java 虚拟机规范中不要求虚拟机在方法区实现垃圾收集。在方法区进行垃圾收集的效率比较低。

>   在堆中，尤其是在新生代中，进行一次垃圾收集一般可以回收 70%~95% 的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

回收废弃常量与回收 Java 堆中的对象非常类似。

>   以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是没有任何 `String` 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生了垃圾回收，而且有必要的话，这个“abc”常量就会被系统清理出常量池。

常量池中的其他类、接口、方法、字段的符号引用也与此类似。

判断一个类是否是无用的类需要同时满足以下 3 个条件：

-   该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
-   加载该类的 `ClassLoader` 已经被回收
-   该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足了上述 3 个条件的无用类进行回收。但是并不是和对象一样，不使用了就必然会被回收。是否对类进行回收，HotSpot 虚拟机提供了 `-Xnoclassgc` 参数进行控制。

### 3.3 垃圾收集算法

介绍几种算法的思想以及发展过程。

#### 标记-清除算法

