##### 17 Kafka、RabbitMQ 以及 RocketMQ 进行技术选型调研

**Kafka的优势和劣势**

- 优势

  Kafka的吞吐量几乎是行业里最优秀的，在常规的机器配置下，一台机器可以达到每秒十几万的QPS。Kafka性能也很高，基本上发送消息给Kafka都是毫秒级的性能。可用性也很高，Kafka是可以支持集群部署的，其中部分机器宕机是可以继续运行的。

- 劣势

  Kafka收到消息之后会写入一个磁盘缓冲区里，并没有直接落地到物理磁盘上去，所以要是机器本身故障了，可能会导致磁盘缓冲区里的数据丢失。

  功能非常的单一，主要是支持收发消息。

Kafka一般用在用户行为日志的采集和传输上，因为日志适当丢失数据是没有关系的，而且一般量特别大，要求吞吐量要高，一般就是收发消息，不需要太多的高级功能。

**RabbitMQ的优势和劣势**

- 优势

  可以保证数据不丢失，也能保证高可用性，即集群部署的时候部分机器宕机可以继续运行，然后支持部分高级功能，比如说死信队列，消息重试。
  
- 缺点

  吞吐量比较低，一般就是每秒几万的级别，所以如果遇到特别特别高并发的情况下，支撑起来是有点困难的。

  在进行集群扩展的时候比较麻烦。

  开发语言是erlang，国内很少有精通erlang语言的工程师，因此也没办法去阅读他的源代码，甚至修改他的源代码。

**RocketMQ的优势和劣势**

- 优势

  吞吐量很高，单机可以达到10万QPS以上，而且可以保证高可用性，性能很高，而且支持通过配置保证数据绝对不丢失，可以部署大规模的集群，还支持各种高级的功能，比如说延迟消息、事务消息、消息回溯、死信队列、消息积压，等等。

  基于Java开发，符合国内大多数公司的技术栈。

- 劣势

  文档相对简单

---

##### 21 消息中间件路由中心的架构原理是什么

`NameServer`可以进行集群化部署。每个`Broker`启动时向所有的`NameServer`进行注册。

生产者和消费者会主动去`NameServer`获取`Broker`的路由信息，通过这些信息，每个系统可以知道发送或者获取消息去哪个`Broker`节点。

`Broker`每隔`30s`会给所有的`NameServer`发送心跳，`NameServer`收到一个`Broker`的心跳，就会更新它的心跳时间。
`NameServer`每隔`10s`会运行一个任务，去检查每个`Broker`的心跳时间，如果某个`Broker`超过`120s`都没有发送心跳，就认为这个`Broker`已经挂掉了。

---

##### 23 Broker的主从架构原理是什么

- Master Broker是如何将消息同步给Slave Broker的？

  RocketMQ的Master-Slave模式采取的是Slave Broker不停的发送请求到Master Broker去拉取消息，也就是通过**Pull模式**拉取消息

- 消费者的系统在获取消息的时候，是从Master Broker获取的？还是从Slave Broker获取的？

  有可能从Master Broker获取消息，也有可能从Slave Broker获取消息

  消费者的系统在获取消息的时候会先发送请求到Master Broker上去，请求获取一批消息，此时Master Broker是会返回一批消息给消费者系统的。

  然后Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的负载情况和Slave Broker的同步情况，向消费者系统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。

##### 消息中间件生产部署架构

- Broker跟NameServer之间的通信是基于什么协议来进行的？

  Broker会跟每个NameServer都建立一个TCP长连接，然后定时通过TCP长连接发送心跳请求过去。

  每个Broke在进行定时的心跳汇报给NameServer的时候，都会告诉NameServer自己当前的数据情况，比如有哪些Topic的哪些数据在自己这里，这些信息都是属于路由信息的一部分。

---

##### 31 进行OS内核参数和JVM参数的调整

os内核参数

- `vm.overcommit_memory`

  这个参数有三个值可以选择，0、1、2。

  如果值是0的话（默认），在中间件系统申请内存的时候，os内核会检查可用内存是否足够，如果足够的话就分配内存，如果剩余内存不是太够了，就会拒绝申请，进而导致中间件系统异常出错。

  因此一般需要将这个参数的值调整为1，意思是把所有可用的物理内存都允许分配给你，只要有内存就给你来用，这样可以避免申请内存失败的问题。

  2表示禁止。

- `vm.max_map_count`

  会影响中间件系统可以开启的线程的数量，默认值是65536。

- `vm.swappiness`

  用来控制进程的swap行为。默认值是60。

  os会把一部分磁盘空间作为swap区域，然后如果有的进程现在可能不是太活跃，就会被操作系统把进程调整为睡眠状态，把进程中的数据放入磁盘上的swap区域，然后让这个进程把原来占用的内存空间腾出来，交给其他活跃运行的进程来使用。

  如果这个参数的值为0，意思是尽量别把任何一个进程放到磁盘swap区域去，尽量大家都用物理内存。

  如果这个参数的值为100，意思是尽量把一些进程给放到磁盘swap区域去，内存腾出来给活跃的进程使用。

- `ulimit`

  控制linux上的最大文件链接数的，默认值是1024

JVM G1垃圾回收器参数

- `-XX:G1ReservePercent`

  在G1管理的老年代里预留指定的空闲内存，保证新生代对象晋升到老年代的时候有足够空间，避免老年代内存都满了，新生代有对象要进入老年代没有充足内存

- `-XX:-OmitStackTraceInFastThrow`

  有时候JVM会抛弃一些异常堆栈信息，因此这个参数设置之后，就是禁用这个特性，要把完整的异常堆栈信息打印出来

- `-XX:+AlwaysPreTouch`

  刚开始指定JVM用多少内存，不会真正分配给他，会在实际需要使用的时候再分配给他。

  使用这个参数之后，就是强制让JVM启动的时候直接分配我们指定的内存，不要等到使用内存的时候再分配

- `-XX:MaxDirectMemorySize`

  限定了direct buffer最多申请多少

- `-XX:-UseLargePages`

  禁用大内存页

- `-XX:-UseBiasedLocking`

  禁用偏向锁

##### 39 MQ使用方式

生产者发送消息的方式：

- 同步发送模式

  发送消息等待MQ的返回结果再继续往下执行
  
- 异步发送模式
  
  发送消息之后不需要等待MQ的返回，当MQ返回时调用回调函数
  
- 单向消息模式

  发送消息后，不关注MQ返回的结果是成功还是失败，直接往下执行。

消费者获取消息的方式：

- push模式

  `Broker`主动把消息发送给消费者

- pull模式

  消费者主动发送请求到`Broker`拉取消息

##### 45 基于MQ实现秒杀订单系统的异步化架构

对于一个秒杀系统而言，比较重要的有以下几点：

- 在前端/客户端设置秒杀答题，错开大量人下单的时间，阻止作弊器刷单

- 独立出来一套秒杀系统，专门负责处理秒杀请求

  防止秒杀下单请求耗尽了订单系统的资源，或者导致系统不稳定，然后导致其他普通下单请求也出现问题，没有办法完成的下单。

- 优先基于Redis进行高并发的库存扣减，一旦库存扣完则秒杀结束

  将每个秒杀商品的库存提前写入Redis中，然后当请求到来之后，就直接对Redis中的库存进行扣减，

  Redis是可以轻松用单机抗每秒几万高并发的

- 秒杀结束之后，Nginx层过滤掉无效的请求，大幅度削减转发到后端的流量

  Redis中的库存被扣减完之后，就说明商品已经被抢购完毕了。此时我们可以让Nginx在接收到后续请求的时候，直接就把后续请求过滤掉。

  比如一旦商品抢购完毕，可以在ZooKeeper中写入一个秒杀完毕的标志位，然后ZK会反向通知Nginx中我们自己写的Lua脚本，通过Lua脚本后续在请求过来的时候直接过滤掉，不要向后转发了。

- 瞬时生成的大量下单请求直接进入RocketMQ进行削峰，订单系统慢慢拉取消息完成下单操作

  秒杀成功了需要生成订单，此时就直接发送一个消息到RocketMQ中，然后让普通订单系统从RocketMQ中消费秒杀成功的消息进行常规性的流程处理即可。

##### 49 生产者是如何发送消息的

- **Topic、MessageQueue以及Broker之间到底是什么关系**

  MessageQueue就是RocketMQ中非常关键的一个数据分片机制，他通过MessageQueue将一个Topic的数据拆分为了很多个数据分片，然后在每个Broker机器上都存储一些MessageQueue。通过这个方法，就可以实现Topic数据的分布式存储。

- **生产者发送消息的时候写入哪个MessageQueue**

  生产者再跟NameServer进行通信时会获取Topic的路由数据。

  所以生产者从NameServer中就会知道，一个Topic有几个MessageQueue，哪些MessageQueue在哪台Broker机器上，哪些MesssageQueue在另外一台Broker机器上。

  基于不同的写入策略，让一个Topic中的数据分散在多个不同的MessageQueue中。

- **如果某个Broker出现故障该怎么办**

  通过在Producer中通过参数`sendLatencyFaultEnable`来开启自动容错机制：在一个Broker故障之后，自动回避一段时间不访问这个Broker，过段时间再去访问他。

  过一段时间之后，可能这个Master Broker就已经恢复好了，比如它的Slave Broker切换为了Master。