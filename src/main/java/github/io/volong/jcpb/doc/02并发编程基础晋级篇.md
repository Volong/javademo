### 共享变量的内存可见性问题

Java 中多线程下处理共享变量时的内存模型：

![c0048a86c27ad140a3e02686d2ebcadb.png](../images/c0048a86c27ad140a3e02686d2ebcadb.png)

Java 内存模型规定所有的变量都存放在主内存中，当线程使用变量时都是把主内存里面的变量拷贝到自己的工作空间或者叫做工作内存。

![aea17d9cc54e53c5e889b1e9b53836e6.png](../images/aea17d9cc54e53c5e889b1e9b53836e6.png)

上图为双核 CPU 系统架构，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算，并且有自己的一级缓存，并且有些架构里面双核还有共享的二级缓存。

在这里 L1 或者 L2 缓存或者 CPU 的寄存器对应 Java 内存模型里面的工作内存。

### Java 中 synchronized 关键字

synchronized 块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以当做一个同步锁的功能来使用，这些   Java 内置的、使用者看不到的锁被称为内部锁。

线程在进入 synchronized 代码块前会自动尝试获取内部锁，如果这时内部锁没有被其它线程占有，则当前线程就获取到了内部锁，这时其它企图访问改代码的线程将会阻塞。

拿到内部锁的线程会在正常退出同步代码块，或者抛出异常后，或者在同步快内调用了该内置锁资源的 wait 系列方法时，会释放该内置锁。

内置锁是排它锁，当一个线程获取了这个锁后，其它线程必须等待该线程释放锁才能获取该锁。

synchronized 的内存语义可以解决共享变量内存不可见性问题。

线程进入 synchronized 块的语义会把在 synchronized 快内使用到的变量从线程的工作内存中清除，在 synchronized 块内使用该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。

退出 synchronized 块的内存语义是会把 synchronized 块内对共享变量的修改刷新到主内存。

除了解决共享变量内存可见性问题外， synchronized 经常被用来实现原子性操作。

synchronized 关键字会引起线程上下文切换和线程调度的开销。

### Java 中 volatile 关键字

当线程获取 volatile 修饰的变量的值时，会首先清空线程工作内存中该变量的值，然后从主内存获取该变量的值。

当线程写入 volatile 修饰的变量的值时，会先把修改后的值写入写入工作内存，然后刷新到主内存。这保证了对一个变量的更新，其它线程马上可见。

volatile 只提供了可见性，但是并没有保证操作的原子性。

变量被声明为 volatile 还可以避免重排序的发生。

### Java 中的 CAS 操作和 AtomicLong 实现原理

#### CAS 来源

CAS 即比较并交换 (Compare And Swap)，是 JDK 提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性，JDK 里面的 Unsafe 类提供了一系列的 `compareAndSwap*` 方法。

例：compareAndSwapLong 方法

```java
boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update)
```

操作含义为：如果对象 obj 的内存偏移量为 valueOffset 位置的变量值为 expect 则使用新值 update 替换旧的值 expect。这个是处理器提供的一个原子性指令。

### 伪共享

#### 什么是伪共享

计算机系统为了解决主内存与 CPU 运行速度的差距，在 CPU 与主内存之间添加了一级或者多级高速缓冲存储器 (Cache)，这个 Cache 一般是集成到 CPU 内部的，所以也叫 CPU Cache。下图为两级 Cache 结构：

![4c04cbd0-32f1-11e8-a1cf-4d9c1e1337da.png](../images/4c04cbd0-32f1-11e8-a1cf-4d9c1e1337da.png)

Cache 内部是按行存储的，其中每一行称为一个 Cache 行，Cache 行是 Cache 与主内存进行数据交换的单位，Cache 行的大小一般为 2 的幂次数字节。

![57d5d9e0-32f1-11e8-a1cf-4d9c1e1337da](../images/57d5d9e0-32f1-11e8-a1cf-4d9c1e1337da)

当 CPU 访问某一个变量的时候，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否则就去主内存里面获取该变量，然后把该变量所在内存区域的一个 Cache 行大小的内存拷贝到 Cache (Cache 行是 Cache 与主内存进行数据交换的单位)。

由于存放到 Cache 行的是内存块而不是单个变量，所以可能会把多个变量存放到一个 Cache 行。

当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行时的性能会有所下降，这就是伪共享。

> 每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。
>
> 缓存行有效地引用主内存中的一块地址 。
>
> 见：https://www.cnblogs.com/cyfonly/p/5800758.html

![5db65e20-32f1-11e8-a1cf-4d9c1e1337da](../images/5db65e20-32f1-11e8-a1cf-4d9c1e1337da)

如上图，变量 x, y 同时被放到了 CPU 的一级和二级缓存，当线程1 使用 CPU 1 对变量 x 进行更新的时候，首先会修改 CPU 1 的一级缓存变量 x 所在的缓存行，这时候缓存一致性协议会导致 CPU 2 中变量 x 对应的缓存行失效。

线程2 写入变量 x 的时候只能去二级缓存中查找，这就破坏了一级缓存，而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的 CPU 中相同缓存行里面的变量。

更坏的情况下，如果 CPU 只有一级缓存，那么会导致频繁的直接访问主内存。

#### 为何会出现伪共享

伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同的变量。

为何多个变量会被放入一个缓存行，因为 Cache 与内存交换数据的单位就是 Cache 行，当 CPU 要访问的变量没有在 Cache 命中时，根据程序运行的局部性原理会把该变量在内存中大小为 Cache 行的内存放入缓存行。

也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组的时候，数组里面的多个元素就会被放入到同一个缓存行。

正常情况下，单线程访问的时候，由于数组元素被放入到了一个或者多个 Cache 行，对代码执行是有利的，因为数据都在缓存中，代码执行会更快。

以为数组内数组元素之间内存地址是连续的，当访问数据第一个元素时，会把第一个元素后续若干个元素一块放入到 Cache 行，这样顺序访问数组的时候会在 Cache 中直接命中，就不会去主内存中读取，后续访问也是这样。