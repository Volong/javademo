> 来源： https://gitbook.cn/books/5ac8a7e72a04fd6c83713956/index.html

#### 2.1 AQS - 锁的底层支持

AQS 是一个 FIFO 的双向队列。维持了一个单一的状态信息 `state`。对 AQS 来说，线程同步的关键是对状态值 `state` 进行操作，操作 `state` 的方式分为**独占模式**与**共享模式**。

独占方式下获取和释放资源的方法为：

```java
void acquire(int arg)
void acquireInterruptibly(int arg)
boolean release(int arg)
```

共享模式下获取和释放资源的方法为：

```java
void acquireShared(int arg)
void acquireSharedInterruptibly(int arg)
boolean releaseShared(int arg)
```

获取资源的方法中都有一个带有 `Interruptibly` 关键字的方法。

**不带** `Interruptibly` 关键字的方法不对中断进行响应。也就是线程在获取资源或者获取资源失败的时候，其它线程中断了该线程，那么该线程不会因为被中断而抛出异常，还是继续获取资源或者被挂起。即不会中断进行响应，忽略中断。

**带** `Interruptibly` 关键字的方法会对中断进行响应。即抛出 `InterruptedException` 异常而返回。

#### 2.2 AQS - 条件变量的支持

在调用共享变量的 `notify` 和 `wait` 方法前必须先获取该共享变量的内置锁，同理在调用条件变量的 `signal` 和 `await` 方法前必须先获取条件变量对应的锁。示例如下：

```java
ReentrantLock lock = new ReentrantLock();		
// 创建一个条件变量，一个 lock 可以对应多个条件变量
Condition condition = lock.newCondition();
// 如果在没有获取到锁前调用了条件变量的 await 方法会抛 java.lang.IllegalMonitorStateException 异常。
lock.lock();
				
try {
    // 阻塞当前线程
    condition.await();
    
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}
```

```java
// 获取独占锁
lock.lock();
try {
    condition.signal();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}
```

如下图所示：一个锁对应一个 AQS 阻塞队列 (等待队列)，对应多个条件变量，每个条件变量都有一个各自的条件队列。

![](../images/3e12f860-3b3b-11e8-935b-9d72f9362f36.png)

### 三、独占锁 ReentrantLock 原理

`ReentrantLock` 是可重复的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞后放入该锁的 AQS 阻塞队列 (等待队列) 中。

#### 3.1 类图结构简介

![](../images/39742e45035e9761b6b110d026c9622c.png)

`ReentrantLock` 可以根据参数来决定使用公平锁还是非公平锁。默认使用公平锁。

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

`NonfairSync` 与 `FairSync` 分别实现了获取锁的非公平与公平策略。

非公平策略是指先尝试获取锁的线程并不一定比后尝试获取锁的线程优先获取到锁。

#### 3.2 获取锁

-   `void lock()` 

当一个线程调用该方法，如果没有其它线程获取该锁，并且当前线程之前没有获取该锁，则当前线程会获取到该锁，并设置当前锁的拥有者为当前线程，并且设置 AQS 的 `state` 的值为 `1`。

如果当前线程已经获取过该锁，则将 AQS 的状态值加 `1`。

如果该锁已经被其它线程持有，则当前线程会被放入 AQS 的阻塞队列 (等待队列) 中。

-   `void lockInterruptibly()` 

与 `lock()` 方法类似，只不过该方法会对中断进行响应。如果当前线程在调用该方法时，如果其它线程调用了当前线程 `interrupt()` 方法，则当前会抛出 `InterruptedException` 异常然后返回。

-   `boolean tryLock()` 

尝试获取锁，成功则返回 `true`，否则返回 `false`。该方法并不会引起线程阻塞。

-   `boolean tryLock(long timeout, TimeUnit unit)`

与 `tryLock()` 类似，不同之处在于设置了超时时间，如果超时没有获取到锁，则返回 `false`。

#### 3.3 释放锁

-   `void unlock()`

如果当前线程持有该锁，调用该方法会让 `AQS` 的 `state` 的值减 `1`。如果减去 `1` 之后，`state` 的值为 `0`，则释放该锁。

如果当前线程没有持有锁，调用该方法会抛出 `IllegalMonitorStateException` 异常。

### 读写锁 ReentrantReadWriteLock 原理

`ReentrantReadWriteLock` 采用读写分离，多个线程可以同时获取读锁。

#### 4.1 类图结构介绍

![](../images/74b7daf4ea7f30e13b8fc33d3dbae4ac.png)

AQS 中维护了 `state` 状态来表示是否获取到了锁，但是 `ReentrantReadWriteLock` 需要维护读状态与写状态，一个 `state` 无法做到。所以 `ReentrantReadWriteLock` 使用 `state` 的高 `16` 位表示获取到读锁的线程个数，低 `16` 位表示获取到写锁的线程的可重入次数。

##### 4.1.1 写锁的获取与释放

`ReentrantReadWriteLock` 写锁通过内部类 `WriteLock` 来实现。

-   `void lock()`

    独占锁，只有一个线程可以获取该锁。

    如果当前线程没有获取到读锁或写锁，那么当前线程可以获取到写锁。

    如果已经有其它线程获取到读锁或写锁，那么当前线程将会被阻塞。

    写锁是可重入锁。

-   `void lockInterruptibly()`

    与 `lock` 方法类似。不同之处在于当前线程被中断，会抛出 `InterruptedException`。

-   `boolean tryLock()`

    尝试获取写锁。

    如果没有其它线程持有写锁或者读锁，那么当前线程获取写锁成功，并返回 `true`。

    如果已经有其它线程持有写锁或者读锁，那么会返回 `false`，当前线程不会被阻塞。

    如果当前线程已经持有了写锁，那么 AQS 的 `state` 的增加相应的计数并返回 `true`。

- `boolean tryLock(long timeout, TimeUnit unit)`

  与 `ReentrantLock` 类似。

- `void unlock()`

  与 `ReentrantLock` 类似。

##### 4.1.2 读锁的获取与释放

- `void lock()`

  获取读锁。

  如果没有其它线程获取写锁，则当前线程可以获取读锁，AQS 的高 `16` 位增加 `1`。

  如果有其它线程获取了写锁，则当前线程会被阻塞。

- `void lockInterruptibly()`

  上同

- `boolean tryLock()`

  尝试获取读锁。

  如果没有其它线程获取了写锁，则当前线程获取读锁会成功，并返回 `true`。

  如果已经有其它线程获取了写锁，则直接返回 `false`，当前线程不会被阻塞。

  如果其它线程已经获取了读锁，则将 AQS 的 `state` 高 `16` 位加 `1`，并返回 `true`。 

- `boolean tryLock(long timeout, TimeUnit unit)`

  上同

- `void unlock()`

  上同

`ReentrantReadWriteLock` 底层使用 AQS 实现，利用 `state` 的高 `16` 位表示获取读锁的线程个数，低 `16` 位表示获取写锁的线程的可重入次数。通过 CAS 操作进行操作，实现了读写分离，适用于在读多写少的场景。

![](../images/0001b710-4576-11e8-86dd-5b15ac28dc48.png)

#### 4.2 JDK8 新增的 StampedLock 锁探究







