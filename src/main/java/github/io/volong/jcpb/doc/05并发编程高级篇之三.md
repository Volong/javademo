> 来源： https://gitbook.cn/books/5ac8a7e72a04fd6c83713956/index.html

#### 2.1 AQS - 锁的底层支持

AQS 是一个 FIFO 的双向队列。维持了一个单一的状态信息 `state`。对 AQS 来说，线程同步的关键是对状态值 `state` 进行操作，操作 `state` 的方式分为**独占模式**与**共享模式**。

独占方式下获取和释放资源的方法为：

```java
void acquire(int arg)
void acquireInterruptibly(int arg)
boolean release(int arg)
```

共享模式下获取和释放资源的方法为：

```java
void acquireShared(int arg)
void acquireSharedInterruptibly(int arg)
boolean releaseShared(int arg)
```

获取资源的方法中都有一个带有 `Interruptibly` 关键字的方法。

**不带** `Interruptibly` 关键字的方法不对中断进行响应。也就是线程在获取资源或者获取资源失败的时候，其它线程中断了该线程，那么该线程不会因为被中断而抛出异常，还是继续获取资源或者被挂起。即不会中断进行响应，忽略中断。

**带** `Interruptibly` 关键字的方法会对中断进行响应。即抛出 `InterruptedException` 异常而返回。

#### 2.2 AQS - 条件变量的支持

在调用共享变量的 `notify` 和 `wait` 方法前必须先获取该共享变量的内置锁，同理在调用条件变量的 `signal` 和 `await` 方法前必须先获取条件变量对应的锁。示例如下：

```java
ReentrantLock lock = new ReentrantLock();		
// 创建一个条件变量，一个 lock 可以对应多个条件变量
Condition condition = lock.newCondition();
// 如果在没有获取到锁前调用了条件变量的 await 方法会抛 java.lang.IllegalMonitorStateException 异常。
lock.lock();
				
try {
    // 阻塞当前线程
    condition.await();
    
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}
```

```java
// 获取独占锁
lock.lock();
try {
    condition.signal();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}
```

如下图所示：一个锁对应一个 AQS 阻塞队列 (等待队列)，对应多个条件变量，每个条件变量都有一个各自的条件队列。

![](../images/3e12f860-3b3b-11e8-935b-9d72f9362f36.png)

### 三、独占锁 ReentrantLock 原理

`ReentrantLock` 的类图如下：

![](../images/39742e45035e9761b6b110d026c9622c.png)

`ReentrantLock` 可以根据参数来决定使用公平锁还是非公平锁。默认使用公平锁。

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

`NonfairSync` 与 `FairSync` 分别实现了获取锁的非公平与公平策略。

非公平策略是指先尝试获取锁的线程并不一定比后尝试获取锁的线程优先获取到锁。

