> 来源：https://gitbook.cn/books/5ac70a26d60a134e37dafdd7/index.html

### Unsafe 类探究

JDK 的 rt.jar 包中的 Unsafe 类提供了硬件级别的原子操作。Unsafe 里面的方法都是 native 方法，通过使用 JNI 的方式来访问本地 C++ 实现库。

#### 主要方法介绍

- long objectFieldOffset(Field field) 

返回指定变量在所属类的内存偏移地址，偏移地址仅仅在该 Unsafe 函数中访问指定字段时使用。

> 例：使用 unsafe 获取 AtomicLong 中变量 value 在 AtomicLong 对象中的内存偏移地址

```java
static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicLong.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
}
```

- int arrayBaseOffset(Class arrayClass)

获取数组中第一个元素的地址。

- int arrayIndexScale(Class arrayClass)

获取数组中单个元素占用的字节数 

- compareAndSwapLong(Object obj, long offset, long expect, long update)

比较对象 obj 中偏移量为 offset 的变量的值是不是和 expect 相等，相等则使用 update 值更新，然后返回 true，否者返回 false。

- public native long getLongVolatile(Object obj, long offset)

获取对象 obj 中偏移量为 offset 的变量对应的 volatile 内存语义的值。

- void putLongVolatile(Object obj, long offset, long value)

设置 obj 对象中内存偏移为 offset 的 long 型变量的值为 value，支持 volatile 内存语义。 

- void putOrderedLong(Object obj, long offset, long value) 

设置 obj 对象中 offset 偏移地址对应的 long 型 field 的值为 value。

这是有延迟的 putLongVolatile 方法，并不保证值修改对其它线程立刻可见。变量只有使用 volatile 修饰并且期望被意外修改的时候使用才有用。 

- void park(boolean isAbsolute, long time) 

isAbsolute 等于 false 时候，time 等于 0 表示一直阻塞，time 大于 0 表示等待指定的 time 后阻塞线程会被唤醒，这个 time 是个相对值，是个增量值，也就是相对当前时间累加 time 后当前线程就会被唤醒。

 如果 isAbsolute 等于 true，并且 time 大于 0 表示阻塞后到指定的时间点后会被唤醒，这里 time 是个绝对的时间，是某一个时间点换算为 ms 后的值。

另外当其它线程调用了当前阻塞线程的 interrupt 方法中断了当前线程时候，当前线程也会返回，当其它线程调用了 unpark 方法并且把当前线程作为参数时候当前线程也会返回。 

- void unpark(Object thread)

唤醒调用 park 后阻塞的线程，参数为需要唤醒的线程。

下面为 JDK 8 新增的方法：

- long getAndSetLong(Object obj, long offset, long update) 

获取对象 obj 中偏移量为 offset 的变量 volatile 语义的值，并设置变量 volatile 语义的值为 update。 

- long getAndAddLong(Object obj, long offset, long addValue)

获取对象 obj 中偏移量为 offset 的变量 volatile 语义的值，并设置变量值为原始值 +addValue。 

#### 如何使用 Unsafe 类



