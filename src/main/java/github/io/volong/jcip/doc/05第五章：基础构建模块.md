### 5.1.2 迭代器与 ConcurrentModificationException

无论是直接迭代还是使用 `for-each`，对容器类进行迭代的标准方式都是使用 `Iterator`。

但是，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。

在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且它们表现出的行为是 "及时失败" (fail-fast) 的。

也就是说，当它们发现容器在迭代过程中被修改时，就会抛出 `ConcurrentModificationException` 异常。

这种及时失败的迭代器并不是一种完备的处理机制，而只是捕获异常，因此只能作为并发问题的预警指示器。

它们采用的实现方式是：将计数器的变化与容器关联起来，如果在迭代期间计数器被修改，那么 `hasNext` 或 `next` 将抛出 `ConcurrentModificationException`。

然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，迭代器并没有意识到已经发生了修改。这是一种设计上的权衡，从而降低并发修改操作的检测代码对程序性能带来的影响。

> 当对象直接从容器中删除而不是通过 `Iterator.remove` 来删除时，即使是在单线程的程序中也会抛出 `ConcurrentModificationException`

要想避免出现 `ConcurrentModificationException`，就必须在迭代过程中持有容器的锁或者克隆容器，在副本上进行迭代。

### 5.1.3 隐藏迭代器

容器的 `toString`、 `hashCode` 和 `equals` 等方法会间接的执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。

`containsAll` 、`removeAll` 和 `retainAll` 等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。

所有这些简介的迭代操作都可能抛出 `ConcurrentModificatcionException`。

## 5.2 并发容器

`ConcurrentHashMap` 用来替代同步基于散列的 `Map`。

`CopyOnWriteArrayList` 用于在遍历操作为主要操作的情况下替代同步的 `List`。

`Queue` 用来临时保存一组等待处理的元素，基于 `LinkedList` 实现。它提供了几种实现：`ConcurrentLinkedQueue` 是一个先进先出队列，`PriorityQueue` (非并发) 是一个优先队列。

`Queue` 上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。

`BlockingQueue` 扩展了 `Queue`，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将会一直阻塞，直到队列中出现一个可用的元素。如果队列已满 (有界队列)，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。

### 5.2.1 ConcurrentHashMap

`ConcurrentHashMap` 使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁。

> Java 8 之前的实现机制

`ConcurrentHashMap` 返回的迭代器具有弱一致性，而并非及时失败。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以 (但是不保证) 在迭代器被构造后将修改操作反应给容器。

### 5.2.2 额外的原子 Map 操作

`ConcurrentMap` 接口中的原子操作：

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    // 仅当 K 没有相应的映射值时才插入
    V putIfAbsent(K key, V value);
    
    // 仅当 K 被映射到 V 时才移除
    boolean remove(K key, V value);
    
    // 仅当 K 被映射到 oldValue 时才替换为 newValue
    boolean replace(K key, V oldValue, V newValue);
    
    // 仅当 K 被映射到某个值时才替换为 newValue
    V replace(K key, V newValue);
}
```

### 5.2.3 CopyOnWriteArrayList



